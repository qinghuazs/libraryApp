# 图书APP用户模块 - 数据安全深度分析文档

## 文档信息
- **文档版本**: 1.0
- **创建日期**: 2025-10-14
- **思考模式**: UltraThink深度分析
- **安全级别**: 企业级数据安全标准

---

## 1. 现有安全设计评估

### 1.1 当前设计的安全措施

✅ **已实现的安全功能：**
- 密码使用bcrypt哈希加密
- 敏感字段（手机号、身份证）加密存储
- 登录失败次数限制（5次锁定30分钟）
- 软删除机制（数据可追溯）
- 登录日志记录（IP、设备、时间）

⚠️ **存在的安全隐患：**
- 用户笔记内容明文存储（数据库泄露风险）
- 没有数据访问审计日志
- 缺少敏感操作的二次验证
- 没有数据导出和注销的完整方案
- 缺少设备信任机制

---

## 2. 深度安全威胁分析

### 2.1 威胁模型（STRIDE）

| 威胁类型 | 具体场景 | 当前防护 | 风险等级 |
|---------|---------|---------|---------|
| **S**poofing（伪装） | 攻击者伪造用户身份登录 | 密码验证、设备指纹 | 🟡 中 |
| **T**ampering（篡改） | 攻击者修改他人的阅读记录 | 权限验证、事务完整性 | 🟢 低 |
| **R**epudiation（抵赖） | 用户否认自己的操作 | 登录日志 | 🟡 中 |
| **I**nformation Disclosure（信息泄露） | 数据库泄露导致笔记内容暴露 | ❌ 无加密 | 🔴 高 |
| **D**enial of Service（拒绝服务） | 恶意用户大量请求攻击 | 限流机制 | 🟡 中 |
| **E**levation of Privilege（权限提升） | 普通用户获取管理员权限 | 权限表、RBAC | 🟢 低 |

---

## 3. 敏感数据加密方案

### 3.1 数据分类与加密策略

| 数据类型 | 敏感级别 | 加密方式 | 示例 |
|---------|---------|---------|------|
| **密码** | 极高 | bcrypt/argon2（单向哈希） | `$2b$12$...` |
| **身份证号** | 极高 | AES-256-GCM + 密钥管理 | `3301***********234` |
| **手机号** | 高 | AES-256-GCM + 密钥管理 | `138****5678` |
| **笔记内容** | 高 | AES-256-GCM（用户专属密钥） | 加密后的Blob |
| **阅读历史** | 中 | 可选加密（隐私模式） | 明文或加密 |
| **邮箱** | 中 | 明文 + 脱敏展示 | `u***@example.com` |
| **用户名** | 低 | 明文 | 无需加密 |

---

### 3.2 笔记内容加密方案设计

#### 方案1：用户专属密钥（推荐）

**原理：**
每个用户拥有独立的加密密钥，笔记使用用户密钥加密。即使数据库泄露，攻击者无法批量解密。

**表结构修改：**
```sql
-- 1. 用户密钥表（加密密钥的密钥）
CREATE TABLE user_encryption_keys (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT UNIQUE NOT NULL,

    -- 用户数据加密密钥（DEK - Data Encryption Key）
    dek_encrypted BLOB NOT NULL COMMENT '加密的数据加密密钥',
    dek_key_id VARCHAR(100) NOT NULL COMMENT '用于加密DEK的KEK ID',

    -- 密钥版本（支持密钥轮换）
    key_version INT DEFAULT 1,

    -- 密钥生成信息
    algorithm VARCHAR(50) DEFAULT 'AES-256-GCM',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    rotated_at DATETIME COMMENT '最后轮换时间',

    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_key_version (key_version)
) COMMENT='用户加密密钥表';

-- 2. 修改笔记表
ALTER TABLE user_reading_notes
ADD COLUMN note_content_encrypted BLOB COMMENT '加密的笔记内容',
ADD COLUMN encryption_key_version INT DEFAULT 1 COMMENT '加密密钥版本',
ADD COLUMN encryption_iv VARCHAR(32) COMMENT '加密初始化向量（IV）';
```

**加密架构图：**
```
┌─────────────────────────────────────────────────┐
│              密钥管理服务 (KMS)                 │
│  ┌──────────────────────────────────────────┐   │
│  │  KEK (Key Encryption Key - 主密钥)       │   │
│  │  存储在HSM或云KMS中                       │   │
│  └──────────────┬───────────────────────────┘   │
│                 │ 加密/解密                      │
│                 ↓                                │
│  ┌──────────────────────────────────────────┐   │
│  │  DEK (Data Encryption Key - 数据密钥)    │   │
│  │  每个用户一个，存储在数据库（加密后）     │   │
│  └──────────────┬───────────────────────────┘   │
└─────────────────┼───────────────────────────────┘
                  │ 加密/解密
                  ↓
         ┌──────────────────────┐
         │   用户笔记明文内容    │
         │  "这本书让我深受启发" │
         └──────────────────────┘
                  │ AES-256-GCM加密
                  ↓
         ┌──────────────────────┐
         │  加密后的Blob数据     │
         │  0x8A3F2E1B...       │
         └──────────────────────┘
                  │
                  ↓ 存储到MySQL
         ┌──────────────────────┐
         │ user_reading_notes   │
         │ note_content_encrypted│
         └──────────────────────┘
```

**实现代码：**

```python
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2
import os
import base64

class UserDataEncryption:
    """用户数据加密服务"""

    def __init__(self, kms_client):
        self.kms = kms_client  # 密钥管理服务客户端

    async def create_user_key(self, user_id: int):
        """为新用户创建加密密钥"""
        # 1. 生成256位随机密钥（DEK）
        dek = os.urandom(32)  # 32 bytes = 256 bits

        # 2. 使用KMS主密钥加密DEK
        kek_id = 'master-key-v1'
        dek_encrypted = await self.kms.encrypt(
            key_id=kek_id,
            plaintext=dek
        )

        # 3. 存储加密后的DEK到数据库
        await mysql.execute("""
            INSERT INTO user_encryption_keys
            (user_id, dek_encrypted, dek_key_id, key_version)
            VALUES (%s, %s, %s, 1)
        """, (user_id, dek_encrypted, kek_id))

        return dek

    async def get_user_key(self, user_id: int) -> bytes:
        """获取用户的解密密钥"""
        # 1. 从数据库读取加密的DEK
        key_record = await mysql.fetchone("""
            SELECT dek_encrypted, dek_key_id, key_version
            FROM user_encryption_keys
            WHERE user_id = %s
        """, (user_id,))

        if not key_record:
            raise ValueError(f"No encryption key found for user {user_id}")

        # 2. 使用KMS解密DEK
        dek = await self.kms.decrypt(
            key_id=key_record['dek_key_id'],
            ciphertext=key_record['dek_encrypted']
        )

        # 3. 缓存到Redis（TTL: 1小时）
        redis.setex(
            f'user:dek:{user_id}',
            3600,
            base64.b64encode(dek)
        )

        return dek

    def encrypt_note_content(self, user_id: int, dek: bytes,
                            plaintext: str) -> tuple:
        """加密笔记内容"""
        # 1. 生成随机IV（初始化向量）
        iv = os.urandom(12)  # GCM模式推荐12字节IV

        # 2. 使用AES-256-GCM加密
        cipher = Cipher(
            algorithms.AES(dek),
            modes.GCM(iv),
            backend=default_backend()
        )
        encryptor = cipher.encryptor()

        # 3. 加密数据
        plaintext_bytes = plaintext.encode('utf-8')
        ciphertext = encryptor.update(plaintext_bytes) + encryptor.finalize()

        # 4. 获取认证标签（GCM模式提供）
        tag = encryptor.tag

        # 5. 返回：密文、IV、认证标签
        return ciphertext + tag, base64.b64encode(iv).decode()

    def decrypt_note_content(self, user_id: int, dek: bytes,
                            ciphertext_with_tag: bytes, iv_b64: str) -> str:
        """解密笔记内容"""
        # 1. 解析IV
        iv = base64.b64decode(iv_b64)

        # 2. 分离密文和认证标签（最后16字节是tag）
        ciphertext = ciphertext_with_tag[:-16]
        tag = ciphertext_with_tag[-16:]

        # 3. 使用AES-256-GCM解密
        cipher = Cipher(
            algorithms.AES(dek),
            modes.GCM(iv, tag),
            backend=default_backend()
        )
        decryptor = cipher.decryptor()

        # 4. 解密并验证
        try:
            plaintext_bytes = decryptor.update(ciphertext) + decryptor.finalize()
            return plaintext_bytes.decode('utf-8')
        except Exception as e:
            # 解密失败（可能是数据被篡改）
            raise ValueError(f"Failed to decrypt note: {e}")
```

**使用示例：**

```python
class NoteService:
    """笔记服务"""

    def __init__(self):
        self.encryption = UserDataEncryption(kms_client)

    async def create_note(self, user_id: int, book_id: int,
                         note_content: str):
        """创建加密笔记"""
        # 1. 获取用户密钥
        dek = await self.encryption.get_user_key(user_id)

        # 2. 加密笔记内容
        ciphertext, iv = self.encryption.encrypt_note_content(
            user_id, dek, note_content
        )

        # 3. 存储到数据库
        await mysql.execute("""
            INSERT INTO user_reading_notes
            (user_id, book_id, note_content_encrypted, encryption_iv,
             encryption_key_version, created_at)
            VALUES (%s, %s, %s, %s, 1, NOW())
        """, (user_id, book_id, ciphertext, iv))

    async def get_note_content(self, note_id: int, user_id: int) -> str:
        """读取并解密笔记内容"""
        # 1. 从数据库读取加密数据
        note = await mysql.fetchone("""
            SELECT note_content_encrypted, encryption_iv, encryption_key_version
            FROM user_reading_notes
            WHERE id = %s AND user_id = %s
        """, (note_id, user_id))

        if not note:
            raise ValueError("Note not found")

        # 2. 获取用户密钥
        dek = await self.encryption.get_user_key(user_id)

        # 3. 解密内容
        plaintext = self.encryption.decrypt_note_content(
            user_id,
            dek,
            note['note_content_encrypted'],
            note['encryption_iv']
        )

        return plaintext
```

---

### 3.3 密钥轮换机制

**为什么需要密钥轮换？**
- 定期更换密钥可降低密钥泄露风险
- 符合安全合规要求（如PCI DSS要求定期轮换）
- 限制单个密钥的使用范围

**轮换策略：**
```python
class KeyRotation:
    """密钥轮换服务"""

    async def rotate_user_key(self, user_id: int):
        """轮换用户密钥（每季度执行一次）"""
        # 1. 获取旧密钥
        old_dek = await encryption.get_user_key(user_id)

        # 2. 生成新密钥
        new_dek = os.urandom(32)

        # 3. 使用KMS加密新密钥
        kek_id = 'master-key-v1'
        new_dek_encrypted = await kms.encrypt(
            key_id=kek_id,
            plaintext=new_dek
        )

        # 4. 更新密钥版本
        await mysql.execute("""
            UPDATE user_encryption_keys
            SET dek_encrypted = %s,
                key_version = key_version + 1,
                rotated_at = NOW()
            WHERE user_id = %s
        """, (new_dek_encrypted, user_id))

        new_version = await mysql.fetchone("""
            SELECT key_version FROM user_encryption_keys
            WHERE user_id = %s
        """, (user_id,))

        # 5. 重新加密所有笔记（后台任务）
        await self.re_encrypt_user_notes(
            user_id, old_dek, new_dek, new_version['key_version']
        )

    async def re_encrypt_user_notes(self, user_id: int, old_dek: bytes,
                                    new_dek: bytes, new_version: int):
        """使用新密钥重新加密用户的所有笔记"""
        # 1. 查询用户所有笔记
        notes = await mysql.fetchall("""
            SELECT id, note_content_encrypted, encryption_iv
            FROM user_reading_notes
            WHERE user_id = %s AND encryption_key_version < %s
        """, (user_id, new_version))

        # 2. 逐条重新加密
        for note in notes:
            # 2.1 使用旧密钥解密
            plaintext = encryption.decrypt_note_content(
                user_id,
                old_dek,
                note['note_content_encrypted'],
                note['encryption_iv']
            )

            # 2.2 使用新密钥加密
            new_ciphertext, new_iv = encryption.encrypt_note_content(
                user_id,
                new_dek,
                plaintext
            )

            # 2.3 更新数据库
            await mysql.execute("""
                UPDATE user_reading_notes
                SET note_content_encrypted = %s,
                    encryption_iv = %s,
                    encryption_key_version = %s
                WHERE id = %s
            """, (new_ciphertext, new_iv, new_version, note['id']))

        logger.info(f"Rotated encryption key for user {user_id}, "
                   f"re-encrypted {len(notes)} notes")
```

---

## 4. 隐私保护功能设计

### 4.1 无痕阅读模式

**需求场景：**
用户可能阅读一些不希望被记录的书籍（如：敏感话题、私人内容）。

**表结构修改：**
```sql
-- 用户偏好设置表增加字段
ALTER TABLE user_preferences
ADD COLUMN incognito_mode BOOLEAN DEFAULT FALSE COMMENT '无痕阅读模式（全局）',
ADD COLUMN history_retention_days INT DEFAULT 365 COMMENT '历史记录保留天数',
ADD COLUMN auto_cleanup_enabled BOOLEAN DEFAULT FALSE COMMENT '自动清理历史记录';

-- 阅读记录表增加字段
ALTER TABLE user_reading_records
ADD COLUMN is_incognito BOOLEAN DEFAULT FALSE COMMENT '是否为无痕记录',
ADD COLUMN auto_delete_at DATETIME COMMENT '自动删除时间';
```

**实现逻辑：**

```python
class IncognitoReadingService:
    """无痕阅读服务"""

    async def start_reading(self, user_id: int, book_id: int,
                           incognito: bool = False):
        """开始阅读（支持无痕模式）"""
        if incognito:
            # 无痕模式：只存储在Redis，24小时后自动过期
            redis.setex(
                f'incognito:reading:{user_id}:{book_id}',
                86400,  # 24小时
                json.dumps({
                    'start_time': datetime.now().isoformat(),
                    'current_page': 0,
                    'progress': 0
                })
            )
        else:
            # 普通模式：存储到数据库
            await mysql.execute("""
                INSERT INTO user_reading_records
                (user_id, book_id, is_incognito, start_reading_at)
                VALUES (%s, %s, FALSE, NOW())
            """, (user_id, book_id))

    async def get_reading_history(self, user_id: int,
                                  include_incognito: bool = False):
        """获取阅读历史"""
        # 1. 从MySQL获取普通记录
        sql = """
            SELECT * FROM user_reading_records
            WHERE user_id = %s AND is_incognito = FALSE
        """

        history = await mysql.fetchall(sql, (user_id,))

        # 2. 如果需要，合并无痕记录（从Redis）
        if include_incognito:
            pattern = f'incognito:reading:{user_id}:*'
            incognito_keys = redis.keys(pattern)

            for key in incognito_keys:
                data = json.loads(redis.get(key))
                history.append({
                    'book_id': key.split(':')[-1],
                    'is_incognito': True,
                    **data
                })

        return history

    async def auto_cleanup_old_records(self):
        """定时任务：清理过期的阅读记录"""
        # 查询所有启用自动清理的用户
        users = await mysql.fetchall("""
            SELECT user_id, history_retention_days
            FROM user_preferences
            WHERE auto_cleanup_enabled = TRUE
        """)

        for user in users:
            retention_days = user['history_retention_days']

            # 删除超过保留期的记录
            await mysql.execute("""
                UPDATE user_reading_records
                SET deleted_at = NOW()
                WHERE user_id = %s
                AND created_at < DATE_SUB(NOW(), INTERVAL %s DAY)
                AND deleted_at IS NULL
            """, (user['user_id'], retention_days))
```

---

### 4.2 数据脱敏展示

**前端展示时脱敏：**

```python
class DataMasking:
    """数据脱敏工具"""

    @staticmethod
    def mask_phone(phone: str) -> str:
        """手机号脱敏：138****5678"""
        if not phone or len(phone) < 11:
            return phone
        return phone[:3] + '****' + phone[-4:]

    @staticmethod
    def mask_email(email: str) -> str:
        """邮箱脱敏：u***@example.com"""
        if not email or '@' not in email:
            return email

        username, domain = email.split('@')

        if len(username) <= 1:
            masked_username = username
        elif len(username) <= 3:
            masked_username = username[0] + '*' + username[-1]
        else:
            masked_username = username[0] + '***' + username[-1]

        return f"{masked_username}@{domain}"

    @staticmethod
    def mask_id_number(id_number: str) -> str:
        """身份证号脱敏：3301***********234"""
        if not id_number or len(id_number) < 18:
            return id_number
        return id_number[:4] + '***********' + id_number[-3:]

    @staticmethod
    def mask_real_name(name: str) -> str:
        """真实姓名脱敏：张*三、欧阳**"""
        if not name or len(name) < 2:
            return name

        if len(name) == 2:
            return name[0] + '*'
        else:
            return name[0] + '*' * (len(name) - 2) + name[-1]
```

**API响应自动脱敏：**

```python
from functools import wraps
from flask import jsonify

def mask_sensitive_fields(func):
    """装饰器：自动脱敏响应中的敏感字段"""
    @wraps(func)
    async def wrapper(*args, **kwargs):
        result = await func(*args, **kwargs)

        if isinstance(result, dict):
            if 'phone_number' in result:
                result['phone_number'] = DataMasking.mask_phone(
                    result['phone_number']
                )
            if 'email' in result:
                result['email'] = DataMasking.mask_email(result['email'])
            if 'id_number' in result:
                result['id_number'] = DataMasking.mask_id_number(
                    result['id_number']
                )
            if 'real_name' in result:
                result['real_name'] = DataMasking.mask_real_name(
                    result['real_name']
                )

        return jsonify(result)

    return wrapper

# 使用示例
@app.route('/api/users/me')
@mask_sensitive_fields
async def get_current_user():
    user = await user_service.get_user(user_id)
    return user  # 自动脱敏后返回
```

---

## 5. 安全审计系统

### 5.1 数据访问审计表

**为什么需要审计？**
- 追踪敏感数据的访问记录
- 发现异常访问行为
- 满足合规要求（GDPR、SOX、等保）

**表结构设计：**

```sql
CREATE TABLE security_audit_logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,

    -- 操作主体
    user_id BIGINT COMMENT '操作用户ID',
    admin_id BIGINT COMMENT '管理员ID（如果是管理员操作）',
    session_id VARCHAR(100) COMMENT '会话ID',

    -- 操作类型
    action_type VARCHAR(50) NOT NULL COMMENT '操作类型',
    action_category VARCHAR(50) COMMENT '操作分类',

    -- 操作详情
    resource_type VARCHAR(50) COMMENT '资源类型（user/note/book等）',
    resource_id VARCHAR(100) COMMENT '资源ID',
    operation VARCHAR(50) COMMENT '操作（read/write/delete）',

    -- 敏感度标记
    sensitivity_level ENUM('public', 'internal', 'confidential', 'secret')
        DEFAULT 'public' COMMENT '敏感级别',

    -- 操作结果
    status ENUM('success', 'failed', 'blocked') NOT NULL,
    failure_reason VARCHAR(255) COMMENT '失败原因',

    -- 环境信息
    ip_address VARCHAR(45),
    user_agent TEXT,
    device_id VARCHAR(100),

    -- 数据变更（可选，敏感操作记录）
    old_value JSON COMMENT '修改前的值（脱敏）',
    new_value JSON COMMENT '修改后的值（脱敏）',

    -- 时间戳
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_user_id (user_id),
    INDEX idx_action_type (action_type),
    INDEX idx_created_at (created_at),
    INDEX idx_sensitivity (sensitivity_level),
    INDEX idx_status (status)
) COMMENT='安全审计日志表';

-- 分区建议：按月分区
ALTER TABLE security_audit_logs
PARTITION BY RANGE (TO_DAYS(created_at)) (
    PARTITION p202501 VALUES LESS THAN (TO_DAYS('2025-02-01')),
    PARTITION p202502 VALUES LESS THAN (TO_DAYS('2025-03-01')),
    -- 自动创建新分区
);
```

**审计记录实现：**

```python
class SecurityAuditor:
    """安全审计服务"""

    @staticmethod
    async def log_access(user_id: int, action_type: str,
                        resource_type: str, resource_id: str,
                        status: str = 'success',
                        sensitivity: str = 'public',
                        **extra_info):
        """记录数据访问日志"""
        await mysql.execute("""
            INSERT INTO security_audit_logs
            (user_id, action_type, resource_type, resource_id,
             operation, status, sensitivity_level, ip_address,
             user_agent, device_id, created_at)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, NOW())
        """, (
            user_id,
            action_type,
            resource_type,
            resource_id,
            extra_info.get('operation', 'read'),
            status,
            sensitivity,
            extra_info.get('ip_address'),
            extra_info.get('user_agent'),
            extra_info.get('device_id')
        ))

    @staticmethod
    def audit(action_type: str, sensitivity: str = 'public'):
        """装饰器：自动记录审计日志"""
        def decorator(func):
            @wraps(func)
            async def wrapper(*args, **kwargs):
                user_id = kwargs.get('user_id') or args[0] if args else None
                resource_id = kwargs.get('resource_id', 'unknown')

                try:
                    result = await func(*args, **kwargs)

                    # 成功：记录日志
                    await SecurityAuditor.log_access(
                        user_id=user_id,
                        action_type=action_type,
                        resource_type=func.__name__,
                        resource_id=str(resource_id),
                        status='success',
                        sensitivity=sensitivity
                    )

                    return result

                except Exception as e:
                    # 失败：记录日志
                    await SecurityAuditor.log_access(
                        user_id=user_id,
                        action_type=action_type,
                        resource_type=func.__name__,
                        resource_id=str(resource_id),
                        status='failed',
                        sensitivity=sensitivity,
                        failure_reason=str(e)
                    )
                    raise

            return wrapper
        return decorator
```

**使用示例：**

```python
class UserService:
    """用户服务"""

    @SecurityAuditor.audit('view_user_profile', sensitivity='internal')
    async def get_user_profile(self, user_id: int):
        """查看用户资料（自动审计）"""
        return await mysql.fetchone("""
            SELECT * FROM users WHERE id = %s
        """, (user_id,))

    @SecurityAuditor.audit('update_sensitive_info', sensitivity='confidential')
    async def update_phone_number(self, user_id: int, new_phone: str):
        """更新手机号（自动审计）"""
        # 记录旧值
        old_user = await mysql.fetchone(
            "SELECT phone_number FROM users WHERE id = %s", (user_id,)
        )

        # 更新
        await mysql.execute("""
            UPDATE users SET phone_number = %s WHERE id = %s
        """, (new_phone, user_id))

        # 审计日志会记录操作详情
```

---

### 5.2 异常访问检测

**实时检测规则：**

```python
class AnomalyDetector:
    """异常行为检测"""

    async def detect_suspicious_activity(self, user_id: int):
        """检测可疑活动"""
        # 规则1：短时间内大量访问（可能是爬虫）
        recent_access_count = await redis.incr(
            f'access_count:{user_id}',
            ex=60  # 1分钟内
        )

        if recent_access_count > 100:
            await self.alert_suspicious('high_frequency_access', user_id)
            # 临时封禁
            await self.block_user(user_id, duration_minutes=30)

        # 规则2：异地登录（IP地理位置突变）
        last_ip = await redis.get(f'last_ip:{user_id}')
        current_ip = request.remote_addr

        if last_ip and last_ip != current_ip:
            last_location = await self.get_ip_location(last_ip)
            current_location = await self.get_ip_location(current_ip)

            # 如果距离超过500公里，触发预警
            distance = self.calculate_distance(
                last_location, current_location
            )

            if distance > 500:
                await self.alert_suspicious('remote_login', user_id, {
                    'last_location': last_location,
                    'current_location': current_location,
                    'distance_km': distance
                })

                # 要求二次验证
                await self.require_2fa(user_id)

        # 规则3：深夜异常活跃（02:00-05:00大量操作）
        hour = datetime.now().hour
        if 2 <= hour <= 5:
            hourly_actions = await redis.incr(
                f'night_actions:{user_id}:{datetime.now().date()}',
                ex=86400
            )

            if hourly_actions > 50:
                await self.alert_suspicious('night_activity', user_id)

    async def alert_suspicious(self, alert_type: str, user_id: int,
                              details: dict = None):
        """发送安全预警"""
        await mysql.execute("""
            INSERT INTO security_alerts
            (user_id, alert_type, alert_level, details, created_at)
            VALUES (%s, %s, 'warning', %s, NOW())
        """, (user_id, alert_type, json.dumps(details)))

        # 发送通知给安全团队
        await notification_service.send_security_alert(
            user_id, alert_type, details
        )
```

---

## 6. 设备信任机制

### 6.1 设备指纹与信任管理

**表结构：**

```sql
-- 用户设备表增加信任相关字段
ALTER TABLE user_devices
ADD COLUMN trust_level ENUM('untrusted', 'trusted', 'verified')
    DEFAULT 'untrusted' COMMENT '信任级别',
ADD COLUMN trusted_at DATETIME COMMENT '标记为受信任的时间',
ADD COLUMN device_fingerprint VARCHAR(255) COMMENT '设备指纹（多因子）',
ADD COLUMN risk_score DECIMAL(5, 2) DEFAULT 0.00 COMMENT '风险评分（0-100）';
```

**设备指纹计算：**

```python
import hashlib
import json

class DeviceFingerprint:
    """设备指纹生成"""

    @staticmethod
    def generate(device_info: dict) -> str:
        """生成设备指纹"""
        # 组合多个设备特征
        features = {
            'device_type': device_info.get('device_type'),
            'os_version': device_info.get('os_version'),
            'screen_resolution': device_info.get('screen_resolution'),
            'timezone': device_info.get('timezone'),
            'language': device_info.get('language'),
            'user_agent': device_info.get('user_agent'),
            # 不包含易变的特征（如IP、GPS）
        }

        # 排序后序列化（保证一致性）
        canonical_json = json.dumps(features, sort_keys=True)

        # 计算哈希
        fingerprint = hashlib.sha256(canonical_json.encode()).hexdigest()

        return fingerprint

    @staticmethod
    async def verify_device(user_id: int, device_id: str,
                           fingerprint: str) -> dict:
        """验证设备"""
        # 查询设备记录
        device = await mysql.fetchone("""
            SELECT * FROM user_devices
            WHERE user_id = %s AND device_id = %s
        """, (user_id, device_id))

        if not device:
            # 新设备
            return {
                'is_trusted': False,
                'is_new_device': True,
                'require_verification': True
            }

        if device['trust_level'] == 'verified':
            # 已验证设备
            return {
                'is_trusted': True,
                'is_new_device': False,
                'require_verification': False
            }

        # 指纹匹配度检查
        if device['device_fingerprint'] == fingerprint:
            return {
                'is_trusted': device['trust_level'] == 'trusted',
                'is_new_device': False,
                'require_verification': False
            }
        else:
            # 指纹不匹配，可能是设备信息变更
            return {
                'is_trusted': False,
                'is_new_device': False,
                'require_verification': True,
                'reason': 'fingerprint_mismatch'
            }
```

**新设备验证流程：**

```python
class NewDeviceVerification:
    """新设备验证服务"""

    async def verify_new_device(self, user_id: int, device_id: str,
                               verification_method: str = 'email'):
        """验证新设备"""
        # 1. 生成验证码
        code = self.generate_verification_code()

        # 2. 存储到Redis（10分钟有效）
        redis.setex(
            f'device_verify:{user_id}:{device_id}',
            600,
            code
        )

        # 3. 发送验证码
        if verification_method == 'email':
            await email_service.send_device_verification(user_id, code)
        elif verification_method == 'sms':
            await sms_service.send_device_verification(user_id, code)

    async def confirm_device(self, user_id: int, device_id: str, code: str):
        """确认设备验证"""
        # 1. 验证码校验
        stored_code = redis.get(f'device_verify:{user_id}:{device_id}')

        if not stored_code or stored_code != code:
            raise ValueError("Invalid verification code")

        # 2. 标记设备为已验证
        await mysql.execute("""
            UPDATE user_devices
            SET trust_level = 'verified',
                trusted_at = NOW()
            WHERE user_id = %s AND device_id = %s
        """, (user_id, device_id))

        # 3. 清理验证码
        redis.delete(f'device_verify:{user_id}:{device_id}')

    @staticmethod
    def generate_verification_code(length: int = 6) -> str:
        """生成验证码"""
        import random
        return ''.join([str(random.randint(0, 9)) for _ in range(length)])
```

---

## 7. 数据删除与隐私合规

### 7.1 GDPR "被遗忘权" 实现

**用户数据导出：**

```python
class DataExportService:
    """数据导出服务（GDPR要求）"""

    async def export_user_data(self, user_id: int) -> dict:
        """导出用户所有数据（JSON格式）"""
        # 1. 基础信息
        user = await mysql.fetchone(
            "SELECT * FROM users WHERE id = %s", (user_id,)
        )
        profile = await mysql.fetchone(
            "SELECT * FROM user_profiles WHERE user_id = %s", (user_id,)
        )

        # 2. 阅读记录
        reading_records = await mysql.fetchall(
            "SELECT * FROM user_reading_records WHERE user_id = %s", (user_id,)
        )

        # 3. 笔记（解密后导出）
        notes = await self.export_notes(user_id)

        # 4. 书单
        book_lists = await mysql.fetchall(
            "SELECT * FROM user_book_lists WHERE user_id = %s", (user_id,)
        )

        # 5. 统计数据
        statistics = await mysql.fetchall(
            "SELECT * FROM user_reading_statistics WHERE user_id = %s", (user_id,)
        )

        # 6. 登录日志
        login_logs = await mysql.fetchall("""
            SELECT * FROM user_login_logs
            WHERE user_id = %s
            ORDER BY created_at DESC
            LIMIT 100
        """, (user_id,))

        # 组装导出数据
        export_data = {
            'user_info': {
                'basic': DataMasking.mask_dict(user),
                'profile': profile
            },
            'reading_data': {
                'records': reading_records,
                'notes': notes,
                'book_lists': book_lists
            },
            'statistics': statistics,
            'activity_logs': login_logs,
            'export_time': datetime.now().isoformat(),
            'export_version': '1.0'
        }

        # 生成JSON文件
        export_file = f'/tmp/user_data_{user_id}_{int(time.time())}.json'
        with open(export_file, 'w', encoding='utf-8') as f:
            json.dump(export_data, f, indent=2, ensure_ascii=False)

        return {
            'file_path': export_file,
            'file_size': os.path.getsize(export_file),
            'download_url': await self.upload_to_oss(export_file)
        }

    async def export_notes(self, user_id: int) -> list:
        """导出笔记（解密）"""
        notes = await mysql.fetchall("""
            SELECT id, book_id, note_type, note_content_encrypted,
                   encryption_iv, created_at
            FROM user_reading_notes
            WHERE user_id = %s
        """, (user_id,))

        # 解密笔记内容
        dek = await encryption.get_user_key(user_id)

        decrypted_notes = []
        for note in notes:
            plaintext = encryption.decrypt_note_content(
                user_id,
                dek,
                note['note_content_encrypted'],
                note['encryption_iv']
            )

            decrypted_notes.append({
                'note_id': note['id'],
                'book_id': note['book_id'],
                'note_type': note['note_type'],
                'content': plaintext,
                'created_at': note['created_at'].isoformat()
            })

        return decrypted_notes
```

**用户数据删除（账户注销）：**

```python
class AccountDeletionService:
    """账户注销服务"""

    async def delete_user_account(self, user_id: int,
                                  reason: str = None):
        """删除用户账户（符合GDPR）"""
        # 1. 标记账户为注销状态
        await mysql.execute("""
            UPDATE users
            SET status = 3, -- 注销状态
                deleted_at = NOW()
            WHERE id = %s
        """, (user_id,))

        # 2. 匿名化敏感数据（而非直接删除）
        await self.anonymize_user_data(user_id)

        # 3. 删除加密密钥（笔记将无法解密）
        await mysql.execute("""
            DELETE FROM user_encryption_keys WHERE user_id = %s
        """, (user_id,))

        # 4. 删除Redis缓存
        redis.delete(f'user:dek:{user_id}')
        redis.delete(f'reading:session:{user_id}')

        # 5. 记录审计日志
        await SecurityAuditor.log_access(
            user_id=user_id,
            action_type='delete_account',
            resource_type='user',
            resource_id=str(user_id),
            status='success',
            sensitivity='secret',
            operation='delete'
        )

        # 6. 发送确认邮件
        await email_service.send_account_deletion_confirmation(user_id)

    async def anonymize_user_data(self, user_id: int):
        """匿名化用户数据"""
        anonymous_id = f'deleted_user_{int(time.time())}'

        # 匿名化基础信息
        await mysql.execute("""
            UPDATE users
            SET username = %s,
                phone_number = NULL,
                email = NULL,
                password_hash = 'DELETED'
            WHERE id = %s
        """, (anonymous_id, user_id))

        # 匿名化详细资料
        await mysql.execute("""
            UPDATE user_profiles
            SET nickname = %s,
                real_name = NULL,
                avatar_url = NULL,
                bio = 'This account has been deleted'
            WHERE user_id = %s
        """, (anonymous_id, user_id))

        # 保留统计数据（用于数据分析，但无法关联到个人）
        # 阅读记录、笔记等保留但无法访问
```

---

## 8. 总结与安全检查清单

### 8.1 安全实施优先级

| 安全措施 | 优先级 | 实施复杂度 | 预期耗时 |
|---------|-------|-----------|---------|
| 笔记内容加密 | 🔴 P0 | 高 | 3-4周 |
| 无痕阅读模式 | 🟡 P1 | 低 | 1周 |
| 数据脱敏展示 | 🟡 P1 | 低 | 3天 |
| 安全审计系统 | 🟡 P1 | 中 | 2周 |
| 设备信任机制 | 🟢 P2 | 中 | 2周 |
| 异常检测告警 | 🟢 P2 | 中 | 2周 |
| GDPR合规功能 | 🟡 P1 | 中 | 2周 |

### 8.2 安全检查清单

**数据保护：**
- [ ] 密码使用bcrypt/argon2加密
- [ ] 敏感字段（手机号、身份证）加密存储
- [ ] 笔记内容加密
- [ ] 定期密钥轮换机制
- [ ] 数据传输使用HTTPS/TLS 1.3

**访问控制：**
- [ ] 基于角色的权限控制（RBAC）
- [ ] 最小权限原则
- [ ] 会话超时设置（2小时）
- [ ] 设备信任验证
- [ ] 异地登录二次验证

**审计与监控：**
- [ ] 敏感操作审计日志
- [ ] 异常访问检测
- [ ] 实时安全告警
- [ ] 日志保留至少180天

**隐私合规：**
- [ ] 用户数据导出功能
- [ ] 账户注销与数据匿名化
- [ ] 隐私政策与用户同意
- [ ] 数据保留期限管理

**应急响应：**
- [ ] 数据泄露响应预案
- [ ] 安全事件升级流程
- [ ] 定期安全演练
- [ ] 漏洞修复SLA（24小时内）

---

**文档版本**: 1.0
**最后更新**: 2025-10-14
**下一步**: 查看《03-用户体验优化文档》
