# 图书APP用户模块 - 用户体验优化文档

## 文档信息
- **文档版本**: 1.0
- **创建日期**: 2025-10-14
- **思考模式**: UltraThink深度分析
- **关注重点**: 跨设备体验、离线功能、社交互动

---

## 1. 跨设备同步体验优化

### 1.1 当前痛点分析

**用户场景：**
```
早上：手机上阅读到第50页
中午：iPad继续阅读，但进度没有同步，需要手动翻到第50页
晚上：Kindle上阅读，笔记和划线都不见了
```

**问题根源：**
1. ❌ 缺少实时同步机制
2. ❌ 冲突解决策略不明确
3. ❌ 离线修改无法合并
4. ❌ 不同设备类型的同步优先级未定义

---

### 1.2 跨设备同步架构设计

#### 完整同步表设计

```sql
CREATE TABLE user_sync_records (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    device_id VARCHAR(100) NOT NULL,

    -- 同步对象
    sync_type ENUM('progress', 'bookmark', 'note', 'preference', 'book_list') NOT NULL,
    resource_type VARCHAR(50) COMMENT '资源类型（book/audiobook）',
    resource_id BIGINT COMMENT '资源ID',

    -- 同步数据（JSON格式）
    sync_data JSON NOT NULL,

    -- 同步状态
    sync_status ENUM('pending', 'synced', 'conflict', 'resolved') DEFAULT 'pending',
    conflict_device_id VARCHAR(100) COMMENT '冲突来源设备ID',
    conflict_resolution VARCHAR(50) COMMENT '冲突解决策略',

    -- 时间戳（用于解决冲突）
    client_timestamp BIGINT NOT NULL COMMENT '客户端时间戳（毫秒）',
    server_timestamp BIGINT NOT NULL COMMENT '服务器时间戳（毫秒）',
    synced_at DATETIME COMMENT '同步完成时间',

    -- 版本控制
    version INT DEFAULT 1 COMMENT '数据版本号',
    previous_version INT COMMENT '前一个版本号',

    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_user_device (user_id, device_id),
    INDEX idx_sync_status (sync_status),
    INDEX idx_resource (resource_type, resource_id),
    INDEX idx_sync_type (sync_type)
) COMMENT='跨设备同步记录表';

-- 同步冲突表（记录冲突详情）
CREATE TABLE user_sync_conflicts (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,

    -- 冲突信息
    conflict_type VARCHAR(50) NOT NULL,
    conflict_description TEXT,

    -- 冲突双方
    device_a_id VARCHAR(100) NOT NULL,
    device_a_data JSON NOT NULL,
    device_a_timestamp BIGINT NOT NULL,

    device_b_id VARCHAR(100) NOT NULL,
    device_b_data JSON NOT NULL,
    device_b_timestamp BIGINT NOT NULL,

    -- 解决方案
    resolution_strategy VARCHAR(50) COMMENT 'latest_wins/merge/manual',
    resolved_data JSON COMMENT '解决后的数据',
    resolved_by VARCHAR(50) COMMENT '解决方式（auto/user）',
    resolved_at DATETIME,

    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_user_id (user_id),
    INDEX idx_resolved (resolved_at)
) COMMENT='同步冲突记录表';
```

---

### 1.3 实时同步实现

#### WebSocket同步架构

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  iPhone     │     │   iPad      │     │   Android   │
│  (Device A) │     │  (Device B) │     │  (Device C) │
└──────┬──────┘     └──────┬──────┘     └──────┬──────┘
       │                   │                   │
       │ WebSocket         │ WebSocket         │ WebSocket
       │                   │                   │
       └───────────────────┼───────────────────┘
                           │
                           ↓
                ┌──────────────────────┐
                │   Sync Gateway       │
                │  (WebSocket Server)  │
                └──────────┬───────────┘
                           │
           ┌───────────────┼───────────────┐
           │               │               │
           ↓               ↓               ↓
    ┌───────────┐   ┌───────────┐   ┌───────────┐
    │   Redis   │   │   MySQL   │   │   Kafka   │
    │ (实时队列)│   │(持久化)   │   │(消息队列) │
    └───────────┘   └───────────┘   └───────────┘
```

#### 同步服务实现

```python
import asyncio
import websockets
import json
from datetime import datetime

class SyncService:
    """跨设备同步服务"""

    def __init__(self):
        self.active_connections = {}  # {user_id: {device_id: websocket}}
        self.redis = RedisClient()
        self.mysql = MySQLClient()

    async def handle_client(self, websocket, user_id: int, device_id: str):
        """处理客户端连接"""
        # 1. 注册连接
        if user_id not in self.active_connections:
            self.active_connections[user_id] = {}

        self.active_connections[user_id][device_id] = websocket

        try:
            # 2. 发送初始同步数据
            await self.send_initial_sync(websocket, user_id, device_id)

            # 3. 持续监听消息
            async for message in websocket:
                await self.handle_sync_message(
                    user_id, device_id, json.loads(message)
                )

        except websockets.exceptions.ConnectionClosed:
            pass
        finally:
            # 4. 移除连接
            if user_id in self.active_connections:
                self.active_connections[user_id].pop(device_id, None)

    async def send_initial_sync(self, websocket, user_id: int,
                               device_id: str):
        """发送初始同步数据（客户端连接时）"""
        # 获取该设备最后同步时间
        last_sync = await self.mysql.fetchone("""
            SELECT MAX(server_timestamp) as last_sync_time
            FROM user_sync_records
            WHERE user_id = %s AND device_id = %s
        """, (user_id, device_id))

        last_sync_time = last_sync['last_sync_time'] if last_sync else 0

        # 获取之后的所有更新
        pending_syncs = await self.mysql.fetchall("""
            SELECT * FROM user_sync_records
            WHERE user_id = %s
            AND device_id != %s
            AND server_timestamp > %s
            ORDER BY server_timestamp ASC
        """, (user_id, device_id, last_sync_time))

        # 发送给客户端
        for sync in pending_syncs:
            await websocket.send(json.dumps({
                'type': 'sync_update',
                'sync_type': sync['sync_type'],
                'resource_id': sync['resource_id'],
                'data': sync['sync_data'],
                'timestamp': sync['server_timestamp']
            }))

    async def handle_sync_message(self, user_id: int, device_id: str,
                                  message: dict):
        """处理同步消息"""
        sync_type = message['type']

        if sync_type == 'update_progress':
            await self.sync_reading_progress(user_id, device_id, message)
        elif sync_type == 'add_bookmark':
            await self.sync_bookmark(user_id, device_id, message)
        elif sync_type == 'add_note':
            await self.sync_note(user_id, device_id, message)
        elif sync_type == 'update_preference':
            await self.sync_preference(user_id, device_id, message)

    async def sync_reading_progress(self, user_id: int, device_id: str,
                                    message: dict):
        """同步阅读进度"""
        book_id = message['book_id']
        current_page = message['current_page']
        progress = message['progress']
        client_timestamp = message['timestamp']

        server_timestamp = int(datetime.now().timestamp() * 1000)

        # 1. 检查冲突
        existing_sync = await self.redis.get(
            f'sync:progress:{user_id}:{book_id}'
        )

        if existing_sync:
            existing_data = json.loads(existing_sync)

            # 时间戳冲突检测（5秒内的更新视为冲突）
            time_diff = abs(client_timestamp - existing_data['timestamp'])

            if time_diff < 5000:  # 5秒
                # 冲突：记录冲突信息
                await self.record_conflict(
                    user_id, book_id, existing_data, message
                )

                # 使用最新时间戳的数据
                if client_timestamp > existing_data['timestamp']:
                    winning_data = message
                else:
                    winning_data = existing_data

                await self.resolve_and_broadcast(
                    user_id, book_id, winning_data, 'latest_wins'
                )
                return

        # 2. 无冲突：直接更新
        sync_data = {
            'book_id': book_id,
            'current_page': current_page,
            'progress': progress,
            'timestamp': server_timestamp,
            'device_id': device_id
        }

        # 2.1 更新Redis缓存
        await self.redis.setex(
            f'sync:progress:{user_id}:{book_id}',
            3600,
            json.dumps(sync_data)
        )

        # 2.2 写入同步记录表
        await self.mysql.execute("""
            INSERT INTO user_sync_records
            (user_id, device_id, sync_type, resource_type, resource_id,
             sync_data, sync_status, client_timestamp, server_timestamp,
             version, created_at)
            VALUES (%s, %s, 'progress', 'book', %s, %s, 'synced', %s, %s, 1, NOW())
        """, (
            user_id, device_id, book_id,
            json.dumps(sync_data),
            client_timestamp, server_timestamp
        ))

        # 2.3 更新实际的阅读进度表
        await self.mysql.execute("""
            UPDATE user_reading_records
            SET current_page = %s,
                reading_progress = %s,
                last_reading_at = NOW()
            WHERE user_id = %s AND book_id = %s
        """, (current_page, progress, user_id, book_id))

        # 3. 广播到其他设备
        await self.broadcast_to_other_devices(
            user_id, device_id, {
                'type': 'sync_update',
                'sync_type': 'progress',
                'book_id': book_id,
                'data': sync_data
            }
        )

    async def broadcast_to_other_devices(self, user_id: int,
                                        source_device_id: str,
                                        message: dict):
        """广播消息到用户的其他设备"""
        if user_id not in self.active_connections:
            return

        tasks = []
        for device_id, websocket in self.active_connections[user_id].items():
            if device_id != source_device_id:
                tasks.append(websocket.send(json.dumps(message)))

        if tasks:
            await asyncio.gather(*tasks, return_exceptions=True)

    async def record_conflict(self, user_id: int, book_id: int,
                             data_a: dict, data_b: dict):
        """记录同步冲突"""
        await self.mysql.execute("""
            INSERT INTO user_sync_conflicts
            (user_id, conflict_type, conflict_description,
             device_a_id, device_a_data, device_a_timestamp,
             device_b_id, device_b_data, device_b_timestamp,
             created_at)
            VALUES (%s, 'progress', %s, %s, %s, %s, %s, %s, %s, NOW())
        """, (
            user_id,
            f'Reading progress conflict for book {book_id}',
            data_a['device_id'], json.dumps(data_a), data_a['timestamp'],
            data_b['device_id'], json.dumps(data_b), data_b['timestamp']
        ))
```

---

### 1.4 冲突解决策略

#### 策略1：Last-Write-Wins（最新写入优先）

**适用场景：**
- 阅读进度
- 用户偏好设置
- 最后阅读位置

**实现逻辑：**
```python
def resolve_conflict_latest_wins(conflict: dict) -> dict:
    """最新时间戳的数据获胜"""
    if conflict['device_a_timestamp'] > conflict['device_b_timestamp']:
        return conflict['device_a_data']
    else:
        return conflict['device_b_data']
```

#### 策略2：Merge（合并）

**适用场景：**
- 书签列表
- 笔记列表
- 书单内容

**实现逻辑：**
```python
def resolve_conflict_merge(conflict: dict, sync_type: str) -> dict:
    """合并两边的数据"""
    data_a = conflict['device_a_data']
    data_b = conflict['device_b_data']

    if sync_type == 'bookmark':
        # 合并书签（去重）
        bookmarks_a = set(json.dumps(b) for b in data_a.get('bookmarks', []))
        bookmarks_b = set(json.dumps(b) for b in data_b.get('bookmarks', []))

        merged_bookmarks = [
            json.loads(b) for b in bookmarks_a.union(bookmarks_b)
        ]

        return {'bookmarks': merged_bookmarks}

    elif sync_type == 'note':
        # 合并笔记（按时间排序）
        notes_a = data_a.get('notes', [])
        notes_b = data_b.get('notes', [])

        merged_notes = notes_a + notes_b
        merged_notes.sort(key=lambda x: x['created_at'])

        # 去重（根据note_id）
        seen = set()
        unique_notes = []
        for note in merged_notes:
            if note['note_id'] not in seen:
                seen.add(note['note_id'])
                unique_notes.append(note)

        return {'notes': unique_notes}

    return {}
```

#### 策略3：Manual（手动解决）

**适用场景：**
- 重要的内容修改
- 无法自动合并的冲突

**实现逻辑：**
```python
async def prompt_user_resolve_conflict(user_id: int, conflict_id: int):
    """提示用户手动解决冲突"""
    conflict = await mysql.fetchone("""
        SELECT * FROM user_sync_conflicts WHERE id = %s
    """, (conflict_id,))

    # 1. 推送通知给用户
    await notification_service.send_push(
        user_id,
        title="同步冲突需要您的处理",
        body=f"您的设备在{conflict['conflict_type']}时出现冲突",
        data={
            'conflict_id': conflict_id,
            'action': 'resolve_conflict'
        }
    )

    # 2. 用户在APP中选择
    #    - 使用设备A的数据
    #    - 使用设备B的数据
    #    - 手动合并

    # 3. 等待用户操作（超时自动使用latest_wins策略）
    timeout = 300  # 5分钟
    # ...
```

---

## 2. 离线阅读体验优化

### 2.1 离线内容管理

#### 离线图书表设计

```sql
CREATE TABLE user_offline_books (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    book_id BIGINT NOT NULL,
    device_id VARCHAR(100) NOT NULL,

    -- 下载状态
    download_status ENUM('queued', 'downloading', 'completed', 'failed', 'paused') DEFAULT 'queued',
    download_progress DECIMAL(5, 2) DEFAULT 0.00,

    -- 文件信息
    downloaded_size_bytes BIGINT DEFAULT 0 COMMENT '已下载字节数',
    total_size_bytes BIGINT COMMENT '总字节数',
    file_format VARCHAR(20) COMMENT 'epub/pdf/mobi',
    quality VARCHAR(20) COMMENT 'standard/high/ultra',

    -- 存储信息
    local_storage_path VARCHAR(255) COMMENT '本地存储路径',
    file_hash VARCHAR(64) COMMENT 'SHA-256文件哈希（校验完整性）',

    -- 有效期（VIP用户可能更长）
    expires_at DATETIME COMMENT '离线内容过期时间',
    last_accessed_at DATETIME COMMENT '最后访问时间',

    -- 下载任务信息
    download_started_at DATETIME COMMENT '开始下载时间',
    download_completed_at DATETIME COMMENT '下载完成时间',
    retry_count INT DEFAULT 0 COMMENT '重试次数',
    error_message TEXT COMMENT '错误信息',

    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    UNIQUE KEY uk_user_book_device (user_id, book_id, device_id),
    INDEX idx_download_status (download_status),
    INDEX idx_expires_at (expires_at),
    INDEX idx_user_device (user_id, device_id)
) COMMENT='用户离线图书表';

-- 离线内容章节表（支持按章节下载）
CREATE TABLE user_offline_chapters (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    offline_book_id BIGINT NOT NULL,
    chapter_id BIGINT NOT NULL,

    download_status ENUM('pending', 'completed', 'failed') DEFAULT 'pending',
    local_path VARCHAR(255),
    file_size_bytes BIGINT,

    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (offline_book_id) REFERENCES user_offline_books(id) ON DELETE CASCADE,
    INDEX idx_offline_book (offline_book_id)
) COMMENT='离线章节表';
```

---

### 2.2 智能预下载机制

#### 预测用户阅读意图

```python
class SmartPredownloader:
    """智能预下载服务"""

    async def predict_next_books(self, user_id: int) -> list:
        """预测用户接下来可能阅读的书籍"""
        # 1. 获取用户的"想读"列表
        want_to_read = await mysql.fetchall("""
            SELECT book_id FROM user_reading_records
            WHERE user_id = %s
            AND reading_status = 'want_to_read'
            ORDER BY created_at DESC
            LIMIT 5
        """, (user_id,))

        # 2. 获取用户正在阅读但未完成的书
        reading_now = await mysql.fetchall("""
            SELECT book_id FROM user_reading_records
            WHERE user_id = %s
            AND reading_status = 'reading'
            AND reading_progress < 95
            ORDER BY last_reading_at DESC
            LIMIT 3
        """, (user_id,))

        # 3. 协同过滤推荐（相似用户喜欢的书）
        recommended = await self.collaborative_filtering(user_id, limit=3)

        # 4. 同一作者/系列的其他书
        related_books = await self.get_related_books(user_id, limit=2)

        # 5. 合并并去重
        predicted_books = []
        seen = set()

        for book_list in [want_to_read, reading_now, recommended, related_books]:
            for book in book_list:
                book_id = book['book_id']
                if book_id not in seen:
                    seen.add(book_id)
                    predicted_books.append(book_id)

        return predicted_books[:10]  # 最多预测10本

    async def auto_predownload(self, user_id: int, device_id: str):
        """自动预下载（WiFi环境 + 充电时）"""
        # 1. 检查设备状态
        device_status = await self.get_device_status(user_id, device_id)

        if not device_status['is_wifi'] or not device_status['is_charging']:
            return  # 仅在WiFi+充电时预下载

        # 2. 检查存储空间
        available_space_mb = device_status['available_storage_mb']

        if available_space_mb < 500:  # 至少保留500MB空间
            return

        # 3. 获取预测的书籍
        predicted_books = await self.predict_next_books(user_id)

        # 4. 检查哪些书已经下载
        already_downloaded = await mysql.fetchall("""
            SELECT book_id FROM user_offline_books
            WHERE user_id = %s
            AND device_id = %s
            AND download_status = 'completed'
        """, (user_id, device_id))

        downloaded_ids = {book['book_id'] for book in already_downloaded}

        # 5. 下载未下载的书（按优先级）
        to_download = [
            book_id for book_id in predicted_books
            if book_id not in downloaded_ids
        ]

        for book_id in to_download[:3]:  # 最多预下载3本
            await self.start_download(user_id, book_id, device_id, priority='low')

    async def start_download(self, user_id: int, book_id: int,
                            device_id: str, priority: str = 'normal'):
        """开始下载图书"""
        # 1. 创建下载任务
        await mysql.execute("""
            INSERT INTO user_offline_books
            (user_id, book_id, device_id, download_status,
             download_started_at, created_at)
            VALUES (%s, %s, %s, 'queued', NOW(), NOW())
        """, (user_id, book_id, device_id))

        # 2. 加入下载队列（Redis）
        queue_key = f'download_queue:{priority}'  # low/normal/high
        await redis.lpush(queue_key, json.dumps({
            'user_id': user_id,
            'book_id': book_id,
            'device_id': device_id
        }))

        # 3. 触发下载任务
        await download_worker.process_queue()
```

---

### 2.3 断点续传实现

```python
import aiofiles
import aiohttp

class ResumeableDownloader:
    """支持断点续传的下载器"""

    async def download_book(self, user_id: int, book_id: int,
                           device_id: str):
        """下载图书（支持断点续传）"""
        # 1. 获取下载任务
        task = await mysql.fetchone("""
            SELECT * FROM user_offline_books
            WHERE user_id = %s AND book_id = %s AND device_id = %s
        """, (user_id, book_id, device_id))

        if not task:
            raise ValueError("Download task not found")

        # 2. 获取图书下载URL
        book_info = await self.get_book_download_info(book_id)
        download_url = book_info['url']
        total_size = book_info['size_bytes']
        local_path = self.get_local_path(user_id, book_id)

        # 3. 检查已下载的大小（断点续传）
        downloaded_size = task['downloaded_size_bytes'] or 0

        if downloaded_size > 0 and os.path.exists(local_path):
            # 断点续传：从已下载位置继续
            resume_from = downloaded_size
            mode = 'ab'  # append binary
        else:
            # 全新下载
            resume_from = 0
            mode = 'wb'  # write binary

        # 4. 发起HTTP请求（带Range头）
        headers = {
            'Range': f'bytes={resume_from}-',
            'User-Agent': 'LibraryApp/1.0'
        }

        async with aiohttp.ClientSession() as session:
            async with session.get(download_url, headers=headers) as response:
                if response.status not in [200, 206]:  # 206 Partial Content
                    raise Exception(f"Download failed: {response.status}")

                # 5. 写入文件
                async with aiofiles.open(local_path, mode) as f:
                    chunk_size = 64 * 1024  # 64KB per chunk
                    downloaded = resume_from

                    async for chunk in response.content.iter_chunked(chunk_size):
                        await f.write(chunk)
                        downloaded += len(chunk)

                        # 更新进度
                        progress = (downloaded / total_size) * 100
                        await self.update_progress(
                            user_id, book_id, device_id,
                            downloaded, progress
                        )

                        # 推送进度通知（每5%）
                        if int(progress) % 5 == 0:
                            await self.notify_progress(
                                user_id, device_id, book_id, progress
                            )

        # 6. 下载完成：校验哈希
        file_hash = await self.calculate_file_hash(local_path)

        if file_hash != book_info['expected_hash']:
            # 哈希不匹配，文件损坏
            await self.mark_download_failed(
                user_id, book_id, device_id, 'Hash mismatch'
            )
            return

        # 7. 标记完成
        await mysql.execute("""
            UPDATE user_offline_books
            SET download_status = 'completed',
                downloaded_size_bytes = %s,
                local_storage_path = %s,
                file_hash = %s,
                download_completed_at = NOW()
            WHERE user_id = %s AND book_id = %s AND device_id = %s
        """, (
            downloaded, local_path, file_hash,
            user_id, book_id, device_id
        ))

    async def update_progress(self, user_id: int, book_id: int,
                             device_id: str, downloaded: int, progress: float):
        """更新下载进度"""
        await mysql.execute("""
            UPDATE user_offline_books
            SET downloaded_size_bytes = %s,
                download_progress = %s,
                updated_at = NOW()
            WHERE user_id = %s AND book_id = %s AND device_id = %s
        """, (downloaded, progress, user_id, book_id, device_id))

        # 同时更新Redis（实时查询）
        await redis.setex(
            f'download:progress:{user_id}:{book_id}',
            3600,
            json.dumps({'progress': progress, 'downloaded': downloaded})
        )

    async def calculate_file_hash(self, file_path: str) -> str:
        """计算文件SHA-256哈希"""
        import hashlib

        sha256 = hashlib.sha256()
        async with aiofiles.open(file_path, 'rb') as f:
            while chunk := await f.read(8192):
                sha256.update(chunk)

        return sha256.hexdigest()
```

---

### 2.4 离线内容过期清理

```python
class OfflineContentCleaner:
    """离线内容清理服务"""

    async def clean_expired_books(self):
        """定时任务：清理过期的离线图书"""
        # 1. 查找过期的离线图书
        expired_books = await mysql.fetchall("""
            SELECT * FROM user_offline_books
            WHERE expires_at < NOW()
            AND download_status = 'completed'
        """)

        for book in expired_books:
            # 2. 删除本地文件
            if book['local_storage_path'] and os.path.exists(book['local_storage_path']):
                os.remove(book['local_storage_path'])

            # 3. 更新数据库记录
            await mysql.execute("""
                UPDATE user_offline_books
                SET download_status = 'expired',
                    local_storage_path = NULL
                WHERE id = %s
            """, (book['id'],))

            # 4. 推送通知给用户
            await notification_service.send_push(
                book['user_id'],
                title="离线内容已过期",
                body=f"《{book['book_name']}》的离线内容已过期，请重新下载"
            )

    async def auto_cleanup_lru(self, user_id: int, device_id: str,
                              target_free_space_mb: int = 500):
        """自动清理最少使用的离线图书（LRU策略）"""
        # 1. 获取设备存储空间
        current_free_space = await self.get_device_free_space(user_id, device_id)

        if current_free_space >= target_free_space_mb:
            return  # 空间充足，无需清理

        # 2. 按最后访问时间排序（最久未用的优先清理）
        offline_books = await mysql.fetchall("""
            SELECT * FROM user_offline_books
            WHERE user_id = %s AND device_id = %s
            AND download_status = 'completed'
            ORDER BY last_accessed_at ASC
        """, (user_id, device_id))

        # 3. 逐个删除直到空间足够
        freed_space = 0
        for book in offline_books:
            if current_free_space + freed_space >= target_free_space_mb:
                break

            # 删除文件
            file_size_mb = book['total_size_bytes'] / (1024 * 1024)
            if os.path.exists(book['local_storage_path']):
                os.remove(book['local_storage_path'])
                freed_space += file_size_mb

            # 更新数据库
            await mysql.execute("""
                UPDATE user_offline_books
                SET download_status = 'deleted',
                    local_storage_path = NULL
                WHERE id = %s
            """, (book['id'],))

        logger.info(f"LRU cleanup freed {freed_space:.2f}MB for user {user_id}")
```

---

## 3. 社交互动功能增强

### 3.1 笔记的社交化

#### 公开笔记展示

```sql
-- 笔记点赞表
CREATE TABLE user_note_likes (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    note_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,

    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,

    UNIQUE KEY uk_note_user (note_id, user_id),
    INDEX idx_note_id (note_id),
    INDEX idx_user_id (user_id),

    FOREIGN KEY (note_id) REFERENCES user_reading_notes(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
) COMMENT='笔记点赞表';

-- 笔记评论表
CREATE TABLE user_note_comments (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    note_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,

    comment_content TEXT NOT NULL,
    parent_comment_id BIGINT COMMENT '父评论ID（支持回复）',

    likes_count INT DEFAULT 0,
    replies_count INT DEFAULT 0,

    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at DATETIME,

    INDEX idx_note_id (note_id),
    INDEX idx_user_id (user_id),
    INDEX idx_parent (parent_comment_id),

    FOREIGN KEY (note_id) REFERENCES user_reading_notes(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
) COMMENT='笔记评论表';
```

#### 笔记社区Feed流

```python
class NoteFeedService:
    """笔记社区Feed流服务"""

    async def get_public_notes_feed(self, user_id: int,
                                    page: int = 1, page_size: int = 20):
        """获取公开笔记的Feed流"""
        offset = (page - 1) * page_size

        # 1. 获取用户关注的人
        following_users = await mysql.fetchall("""
            SELECT target_user_id FROM user_relationships
            WHERE user_id = %s AND relationship_type = 'follow'
        """, (user_id,))

        following_ids = [u['target_user_id'] for u in following_users]
        following_ids.append(user_id)  # 包括自己

        # 2. 查询这些用户的公开笔记
        notes = await mysql.fetchall("""
            SELECT
                n.*,
                u.username, u.nickname,
                p.avatar_url,
                b.book_name, b.book_cover,
                n.likes_count, n.comments_count
            FROM user_reading_notes n
            JOIN users u ON n.user_id = u.id
            LEFT JOIN user_profiles p ON u.id = p.user_id
            LEFT JOIN books b ON n.book_id = b.id
            WHERE n.user_id IN (%s)
            AND n.is_public = TRUE
            AND n.deleted_at IS NULL
            ORDER BY n.created_at DESC
            LIMIT %s OFFSET %s
        """, (','.join(map(str, following_ids)), page_size, offset))

        # 3. 解密笔记内容（如果加密）
        for note in notes:
            if note['note_content_encrypted']:
                dek = await encryption.get_user_key(note['user_id'])
                note['content'] = encryption.decrypt_note_content(
                    note['user_id'],
                    dek,
                    note['note_content_encrypted'],
                    note['encryption_iv']
                )
            else:
                note['content'] = note['note_content']

            # 删除加密字段（不返回给前端）
            del note['note_content_encrypted']
            del note['encryption_iv']

        return notes

    async def like_note(self, user_id: int, note_id: int):
        """点赞笔记"""
        # 1. 插入点赞记录（幂等）
        try:
            await mysql.execute("""
                INSERT INTO user_note_likes (note_id, user_id, created_at)
                VALUES (%s, %s, NOW())
            """, (note_id, user_id))

            # 2. 增加笔记的点赞数
            await mysql.execute("""
                UPDATE user_reading_notes
                SET likes_count = likes_count + 1
                WHERE id = %s
            """, (note_id,))

            # 3. 推送通知给笔记作者
            note_author = await mysql.fetchone("""
                SELECT user_id FROM user_reading_notes WHERE id = %s
            """, (note_id,))

            if note_author['user_id'] != user_id:
                await notification_service.send_push(
                    note_author['user_id'],
                    title="有人赞了你的笔记",
                    body=f"你的笔记获得了新的赞"
                )

        except IntegrityError:
            # 已经点赞过了，忽略
            pass

    async def comment_on_note(self, user_id: int, note_id: int,
                             comment_content: str,
                             parent_comment_id: int = None):
        """评论笔记"""
        # 1. 插入评论
        result = await mysql.execute("""
            INSERT INTO user_note_comments
            (note_id, user_id, comment_content, parent_comment_id, created_at)
            VALUES (%s, %s, %s, %s, NOW())
        """, (note_id, user_id, comment_content, parent_comment_id))

        comment_id = result.lastrowid

        # 2. 增加笔记的评论数
        await mysql.execute("""
            UPDATE user_reading_notes
            SET comments_count = comments_count + 1
            WHERE id = %s
        """, (note_id,))

        # 3. 如果是回复评论，增加父评论的回复数
        if parent_comment_id:
            await mysql.execute("""
                UPDATE user_note_comments
                SET replies_count = replies_count + 1
                WHERE id = %s
            """, (parent_comment_id,))

        # 4. 推送通知
        note_author = await mysql.fetchone("""
            SELECT user_id FROM user_reading_notes WHERE id = %s
        """, (note_id,))

        if note_author['user_id'] != user_id:
            await notification_service.send_push(
                note_author['user_id'],
                title="有人评论了你的笔记",
                body=comment_content[:50] + ('...' if len(comment_content) > 50 else '')
            )

        return comment_id
```

---

### 3.2 书单关注与协作

```sql
-- 书单关注表
CREATE TABLE user_book_list_followers (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    list_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,

    followed_at DATETIME DEFAULT CURRENT_TIMESTAMP,

    UNIQUE KEY uk_list_user (list_id, user_id),
    INDEX idx_list_id (list_id),
    INDEX idx_user_id (user_id),

    FOREIGN KEY (list_id) REFERENCES user_book_lists(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
) COMMENT='书单关注表';

-- 书单协作表（允许多人共同维护一个书单）
CREATE TABLE user_book_list_collaborators (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    list_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,

    role ENUM('owner', 'editor', 'contributor') DEFAULT 'contributor',
    permissions JSON COMMENT '权限配置（可添加/删除/排序等）',

    invited_by BIGINT COMMENT '邀请人ID',
    invited_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    accepted_at DATETIME COMMENT '接受邀请时间',

    UNIQUE KEY uk_list_user (list_id, user_id),
    INDEX idx_list_id (list_id),

    FOREIGN KEY (list_id) REFERENCES user_book_lists(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
) COMMENT='书单协作者表';
```

#### 协作书单实现

```python
class CollaborativeBookListService:
    """协作书单服务"""

    async def invite_collaborator(self, list_id: int, owner_id: int,
                                 invitee_user_id: int, role: str = 'contributor'):
        """邀请协作者"""
        # 1. 验证权限（只有owner可以邀请）
        list_info = await mysql.fetchone("""
            SELECT * FROM user_book_lists WHERE id = %s
        """, (list_id,))

        if list_info['user_id'] != owner_id:
            raise PermissionError("Only owner can invite collaborators")

        # 2. 创建邀请
        await mysql.execute("""
            INSERT INTO user_book_list_collaborators
            (list_id, user_id, role, invited_by, invited_at)
            VALUES (%s, %s, %s, %s, NOW())
        """, (list_id, invitee_user_id, role, owner_id))

        # 3. 推送通知
        await notification_service.send_push(
            invitee_user_id,
            title="书单协作邀请",
            body=f"邀请你一起维护书单《{list_info['list_name']}》"
        )

    async def accept_invitation(self, user_id: int, list_id: int):
        """接受协作邀请"""
        await mysql.execute("""
            UPDATE user_book_list_collaborators
            SET accepted_at = NOW()
            WHERE list_id = %s AND user_id = %s
        """, (list_id, user_id))

    async def add_book_to_list(self, list_id: int, user_id: int,
                              book_id: int, recommendation_reason: str = None):
        """添加图书到书单（协作者可操作）"""
        # 1. 检查权限
        has_permission = await self.check_permission(
            list_id, user_id, 'add_book'
        )

        if not has_permission:
            raise PermissionError("No permission to add books")

        # 2. 添加图书
        await mysql.execute("""
            INSERT INTO user_book_list_items
            (list_id, book_id, recommendation_reason, added_by, created_at)
            VALUES (%s, %s, %s, %s, NOW())
        """, (list_id, book_id, recommendation_reason, user_id))

        # 3. 更新书单的图书数量
        await mysql.execute("""
            UPDATE user_book_lists
            SET books_count = books_count + 1
            WHERE id = %s
        """, (list_id,))

        # 4. 通知其他协作者
        await self.notify_collaborators(
            list_id, user_id,
            f"添加了新书到书单"
        )

    async def check_permission(self, list_id: int, user_id: int,
                              action: str) -> bool:
        """检查权限"""
        # 1. 检查是否为书单所有者
        list_info = await mysql.fetchone("""
            SELECT user_id FROM user_book_lists WHERE id = %s
        """, (list_id,))

        if list_info['user_id'] == user_id:
            return True  # 所有者拥有所有权限

        # 2. 检查协作者权限
        collaborator = await mysql.fetchone("""
            SELECT role, permissions FROM user_book_list_collaborators
            WHERE list_id = %s AND user_id = %s
            AND accepted_at IS NOT NULL
        """, (list_id, user_id))

        if not collaborator:
            return False

        # 3. 根据角色检查权限
        if collaborator['role'] == 'editor':
            return action in ['add_book', 'remove_book', 'reorder']
        elif collaborator['role'] == 'contributor':
            return action in ['add_book']

        return False
```

---

## 4. 通知与提醒优化

### 4.1 智能阅读提醒

```python
class SmartReadingReminder:
    """智能阅读提醒服务"""

    async def schedule_reminders(self, user_id: int):
        """为用户安排阅读提醒"""
        # 1. 分析用户的阅读习惯
        habits = await self.analyze_reading_habits(user_id)

        # 2. 根据习惯安排提醒时间
        if habits['preferred_time'] == 'morning':
            reminder_time = '08:30'
        elif habits['preferred_time'] == 'afternoon':
            reminder_time = '14:00'
        elif habits['preferred_time'] == 'evening':
            reminder_time = '20:00'
        else:
            reminder_time = '19:00'  # 默认晚上7点

        # 3. 创建定时提醒
        await self.create_scheduled_notification(
            user_id,
            reminder_time,
            title="该读书了📚",
            body=self.generate_reminder_message(habits)
        )

    async def analyze_reading_habits(self, user_id: int) -> dict:
        """分析用户阅读习惯"""
        # 查询最近30天的阅读记录
        reading_logs = await mysql.fetchall("""
            SELECT HOUR(last_reading_at) as hour,
                   COUNT(*) as count
            FROM user_reading_records
            WHERE user_id = %s
            AND last_reading_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
            GROUP BY HOUR(last_reading_at)
            ORDER BY count DESC
        """, (user_id,))

        if not reading_logs:
            return {'preferred_time': 'evening', 'avg_duration': 30}

        # 找到最常阅读的时间段
        most_frequent_hour = reading_logs[0]['hour']

        if 6 <= most_frequent_hour < 12:
            preferred_time = 'morning'
        elif 12 <= most_frequent_hour < 18:
            preferred_time = 'afternoon'
        else:
            preferred_time = 'evening'

        # 计算平均阅读时长
        avg_duration = await mysql.fetchone("""
            SELECT AVG(reading_duration) as avg
            FROM user_reading_records
            WHERE user_id = %s
            AND last_reading_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
        """, (user_id,))

        return {
            'preferred_time': preferred_time,
            'avg_duration': int(avg_duration['avg'] or 30)
        }

    def generate_reminder_message(self, habits: dict) -> str:
        """生成个性化提醒消息"""
        duration = habits['avg_duration']

        messages = [
            f"每天{duration}分钟阅读，让知识沉淀",
            f"今天的{duration}分钟阅读计划，开始了吗？",
            f"阅读是最好的投资，来读{duration}分钟吧",
            "书籍是人类进步的阶梯，一起爬一层吧",
            "你的书架上还有未完成的故事在等你"
        ]

        import random
        return random.choice(messages)
```

---

## 5. 总结与优先级

### 5.1 用户体验优化实施路线图

| 优化项 | 用户价值 | 优先级 | 实施复杂度 | 预期耗时 |
|-------|---------|-------|-----------|---------|
| 跨设备实时同步 | ⭐⭐⭐⭐⭐ | 🔴 P0 | 高 | 4-5周 |
| 离线阅读支持 | ⭐⭐⭐⭐⭐ | 🔴 P0 | 高 | 3-4周 |
| 断点续传下载 | ⭐⭐⭐⭐ | 🟡 P1 | 中 | 2周 |
| 智能预下载 | ⭐⭐⭐ | 🟢 P2 | 中 | 2周 |
| 笔记社区Feed | ⭐⭐⭐⭐ | 🟡 P1 | 中 | 3周 |
| 协作书单 | ⭐⭐⭐ | 🟢 P2 | 中 | 2周 |
| 智能阅读提醒 | ⭐⭐⭐ | 🟢 P2 | 低 | 1周 |

---

**文档版本**: 1.0
**最后更新**: 2025-10-14
**下一步**: 查看《04-业务增长策略文档》
